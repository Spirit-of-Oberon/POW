(******************************************************************************)
(*                                                                            *)
(**)                        MODULE Error;                                   (**)
(*                                                                            *)
(******************************************************************************)
(* Copyright (c) 1995-98, Robinson Associates                                 *)
(*                        Red Lion House                                      *)
(*                        St Mary's Street                                    *)
(*                        PAINSWICK                                           *)
(*                        Glos                                                *)
(*                        GL6  6QR                                            *)
(*                        Tel:    (+44) (0)452 813 699                        *)
(*                        Fax:    (+44) (0)452 812 912                        *)
(*                        e-Mail: oberon@robinsons.co.uk                      *)
(******************************************************************************)
(* AUTHORS: Richard De Moliner, Bernhard Leisch                               *)
(******************************************************************************)
(* PURPOSE:  Error management                                                 *)
(*                                                                            *)
(* COMMENTS:                                                                  *)
(*   This module defines all possible compiler errors and generates error     *)
(*   messages if necessary.                                                   *)
(******************************************************************************)


IMPORT String;

CONST
  UNDECLARED*=0;
  MULTIPLY_DEFINED*=1;
  ILLEGAL_CHAR_NUM*=2;
  ILLEGAL_CHAR_STRING*=3;
  IDENT_NO_MATCH*=4;
  COMMENT_OPEN*=5;
  EQU_EXPECTED*=9;
  TYPEDEF_STARTS_WRONG*=12;
  FACTOR_STARTS_WRONG*=13;
  STATEMENT_STARTS_WRONG*=14;
  DECL_ENDS_WRONG*=15;
  MODULE_EXPECTED*=16;
  MISSING1*=18;
  MISSING2*=19;
  MISSING3*=20;
  MISSING4*=22;
  MISSING5*=23;
  MISSING6*=24;
  MISSING7*=25;
  MISSING8*=26;
  MISSING9*=27;
  MISSING10*=28;
  MISSING11*=30;
  MISSING12*=34;
  EXPECTED1*=35;
  IDENT_EXPECTED*=38;
  MISSING13*=39;
  MISSING_END*=41;
  MISSING_UNTIL*=44;
  EXIT_OUT_OF_LOOP*=46;
  IDENT_MARKED_WRONG*=47;
  EXPR_SHOULD_BE_CONSTANT*=50;
  CONSTANT_NOT_INT*=51;
  IDENT_NO_TYPE*=52;
  IDENT_NO_RECORD*=53;
  RESULT_TYPE_NOT_BASIC*=54;
  RESULT_IGNORED*=55;
  ASSIGNMENT_TO_NON_VAR*=56;
  POINTER_BOUND_TO_BASIC*=57;
  RECURSIVE_TYPE_DEFINITION*=58;
  ILLEGAL_OPEN_ARRAY_PARAM*=59;
  CASE_LABEL_WRONG_TYPE*=60;
  CASE_LABEL_INADMISSIBLE_TYPE*=61;
  CASE_LABEL_MULTIPLY_DEFINED*=62;
  ILLEGAL_CONST_VALUE*=63;
  MORE_PARAMS*=64;
  FEWER_PARAMS*=65;
  DIFFERENT_ELEM_TYPES*=66;
  PARAM_IS_NO_ARRAY*=67;
  CTRL_VAR_NOT_INT*=68;
  PARAM_NO_INT_CONST*=69;
  WRONG_RECEIVER*=70;
  POINTER_RECEIVER_REQUIRED*=71;
  RECORD_NOT_SAME_SCOPE*=72;
  PROC_LEVEL_0_REQU*=73;
  PROC_UNKNOWN_IN_BASE_TYPE*=74;
  INVALID_BASE_PROC_CALL*=75;
  VAR_READ_ONLY*=76;
  OBJ_IS_NO_RECORD*=77;
  DEREF_OBJ_IS_NO_VARIABLE*=78;
  INX_OBJ_IS_NO_VARIABLE*=79;
  INX_IS_NO_INT*=80;
  INX_OUT_OF_BOUNDS*=81;
  INXED_IS_NO_ARRAY*=82;
  UNDEFINED_REC_FIELD*=83;
  DEREF_VAR_IS_NO_POINTER*=84;
  NO_EXTENSION_OF_VAR_TYPE*=85;
  GUARD_OR_TEST_NOT_A_POINTER*=86;
  TESTES_VAR_NO_OBJ*=87;
  OPEN_ARRAY_NOT_ALLOWED*=88;
  WRONG_IN_OPERAND*=92;
  SET_ELEMENT_NOT_INT*=93;
  LOG_AND_OPERAND_NOT_BOOLEAN*=94;
  LOG_OR_OPERAND_NOT_BOOLEAN*=95;
  OPERAND_INAPPLICABLE1*=96;
  OPERAND_INAPPLICABLE2*=97;
  NOT_OPERAND_NOT_BOOLEAND*=98;
  ASSERT_FAULT*=99;
  INCOMPATIBLE_OP_OPERANDS*=100;
  OPERAND_INAPPLICABLE3*=101;
  OPERAND_INAPPLICABLE4*=102;
  OPERAND_INAPPLICABLE5*=103;
  OPERAND_INAPPLICABLE6*=104;
  OPERAND_INAPPLICABLE7*=105;
  OPERAND_INAPPLICABLE8*=106;
  OPERAND_INAPPLICABLE9*=107;
  OPERAND_INAPPLICABLE10*=108;
  OVERRIDING_METHOD_NOT_EXPORTED*=109;
  OPERAND_NOT_A_TYPE*=110;
  OPERAND_INAPPLICABLE_TO_FUNCT*=111;
  OPERAND_NO_VAR*=112;
  INCOMPATIBLE_ASSIGNMENT*=113;
  STRING_TOO_LONG1*=114;
  PARAMETER_MISMATCH*=115;
  NUMBER_OF_PARAMS_MISMATCH*=116;
  RESULT_TYPE_MISMATCH*=117;
  FORWARD_DECL_EXPORT_MISMATCH*=118;
  REDEFINITION_BEFORE_BASEDEF*=119;
  BOOLEAN_EXPECTED*=120;
  NO_PROC*=121;
  VAR_PARAM_NO_VAR*=122;
  PARAM_TYPE*=123;
  RETURN_TYPE*=124;
  CASE_TYPE*=125;
  NO_PROC_ALLOWED*=126;
  ILLEGAL_OBJ_USE*=127;
  FORWARD_REF*=128;
  FORWARD_PROC*=129;
  WITH_CLAUSE_NO_VAR*=130;
  LEN_WITHOUT_ARRAY*=131;
  LEN_DIMENSION_WRONG*=132;
  SYSTEM_NOT_IMPORTED*=135;
  SYSFLAG_MISMATCH*=136;
  KEY_INCONSISTENT*=150;
  INCORRECT_SYM_FILE*=151;
  SYM_FILE_NOT_FOUND*=152;
  FILE_NOT_OPENED*=153;
  RECURSIVE_IMPORT*=154;
  NO_NEW_SYM_FILE*=155;


  NOT_IMPLEMENTED*=200;
  BOUND_MIXUP*=201;
  SET_ELEM_BOUNDS*=202;
  NUMBER_TOO_LARGE*=203;
  PRODUCT_TOO_LARGE*=204;
  DIV_BY_ZERO*=205;
  SUM_TOO_LARGE*=206;
  DIFF_TOO_LARGE*=207;
  SHIFT_OVERFLOW*=208;
  CASE_RANGE_TOO_LARGE*=209;
  CODE_TOO_LONG*=210;
  JUMP_TOO_FAR*=211;
  TOO_MANY_CASES*=213;
  OUT_OF_REGISTERS*=215;
  OUT_OF_FLOAT_REGISTERS*=216;
  ILLEGAL_VALUE1*=218;
  ILLEGAL_VALUE2*=219;
  ILLEGAL_VALUE*=220;
  TOO_MANY_POINTERS*=221;
  TOO_MANY_GLOBAL_POINTERS*=222;
  TOO_MANY_RECORD_TYPES*=223;
  TOO_MANY_POINTER_TYPES*=224;
  ADDRESS_TOO_LARGE1*=225;
  TOO_MANY_EXPORTED_PROC*=226;
  TOO_MANY_IMPORTED_MOD*=227;
  TOO_MANY_EXPORTED_REC*=228;
  TOO_MANY_NESTED_REC*=229;
  TOO_MANY_CONSTANTS*=230;
  TOO_MANY_LINKS*=231;
  TOO_MANY_COMMANDS*=232;
  TOO_MANY_INHERITANCE_LEVELS*=233;
  RECURSIVE_EXPORT*=234; (* ???? *)
  ADDRESS_TOO_LARGE2*=236;
  IDENT_TOO_LONG*=240;
  STRING_TOO_LONG2*=241;
  ADDR_OVERFLOW*=242;
  IDENT_UNMARKED*=250;
  NOT_WINDOWS*=251;
  NO_VARS_ALLOWED*=252;
  NO_STATS_ALLOWED*=253;
  OBJ_CREATE_ERR*=254;
  RECORD_TOO_LARGE*=255;
  NO_INTPROC_CALL*=256;
  LOCAL_VAR_TOO_LARGE*=257;
  GLOBAL_VAR_TOO_LARGE*=258;
  PARAM_TOO_LARGE*=259;
  SYSTEM_CC_UNSUPPORTED*=260;
  REGISTER_UNREADABLE*=261;
  READ_ONLY_REGISTER*=262;
  CONSTANT_FRAME_TOO_LARGE*=263;
  TOO_MANY_IMPORTED_PROC*=264;
  TOO_MANY_FIXUPS*=265;
  DATA_RECORD_TOO_LARGE*=266;
  OPEN_ARRAY_CONTAINING_POINTERS1*=267;
  EXPORT_NOT_OPENED*=279;
  INCORRECT_LICENSE*=280;
  LICENSE_LIMIT*=281;
  NO_LICENSE*=282;
  PROC_BEGIN_OR_END_EXPECTED*=283;
  INTERNAL_MURKS*=299;
  IMPLICIT_TYPE_CASE*=-301;
  POSSIBLE_SIDE_EFFECT*=-302;
  OPEN_ARRAY_CONTAINING_POINTERS2*=-303;
  POINTER_NOT_INITIALIZED*=-304;
  PROGMAIN_SPELLING*=-305;
  WINMAIN_SPELLING*=-306;
  DLLENTRY_SPELLING*=-307;
  
  FILE_NOT_FOUND*=0400;
  PATH_NOT_FOUND*=0401;
  TOO_MANY_OPEN_FILES*=0402;
  ACCESS_DENIED*=0403;
  WRITE_PROTECTED*=0404;
  SHARING_VIOLATION*=0405;
  NETWORK_ACCESS_DENIED*=0406;
  UNEXPECTED_FILE_ERROR*=407;
  COULD_NOT_CREATE*=408;
  WRONG_SYM_FILE_FORMAT*=409;
  WRONG_SRC_FILENAME*=410;
  EQU_EXPECTED2*=411;
  BASIC_RO_VAR_PARAM*=412;
  ILLEGAL_SYS_FLAG*=413;
  COMPILER_OUT_OF_MEM*=414;
  TOO_MANY_PROCEDURES*=415;
  TOO_MANY_LINES*=416;
  STATICTYPED_IN_MODULE*=417;
  STVARPAR_NO_RECORD*=418;
  STATICTYPED_NO_RECORD*=419;
  INTERNAL_MURKS_WARN*=-420;
  TOO_MANY_DEBUGTYPES*=421;
  CODE_PROC_TOO_LONG*=422;                              
  OUT_OF_MEM_REGS*=423;

  
(* create an error message from a code number and an optional text
   which replaces the first "#" in the error message text *)
PROCEDURE Message*(code:INTEGER; 
                   insText:ARRAY OF CHAR; 
                   VAR msg:ARRAY OF CHAR);
VAR
  i:LONGINT;
BEGIN
  CASE ABS(code) OF
      0:COPY("undeclared identifier",msg);
  |   1:COPY("multiply defined identifier",msg);
  |   2:COPY("illegal character in number",msg);
  |   3:COPY("illegal character in string",msg);
  |   4:COPY("identifier does not match procedure name",msg);
  |   5:COPY("comment not closed",msg);
  |   9:COPY('"=" expected instead of #',msg);
  |  12:COPY("type definition starts with incorrect symbol",msg);
  |  13:COPY("factor starts with incorrect symbol",msg);
  |  14:COPY("statement starts with incorrect symbol",msg);
  |  15:COPY("declaration followed by incorrect symbol",msg);
  |  16:COPY("MODULE expected",msg);
  |  18:COPY('"." missing',msg);
  |  19:COPY('"," missing',msg);
  |  20:COPY('":" missing',msg);
  |  22:COPY('")" missing',msg);
  |  23:COPY('"]" missing',msg);
  |  24:COPY('"}" missing',msg);
  |  25:COPY('OF missing',msg);
  |  26:COPY('THEN missing',msg);
  |  27:COPY('DO missing',msg);
  |  28:COPY('TO missing',msg);
  |  30:COPY('"(" missing',msg);
  |  34:COPY('":=" missing',msg);
  |  35:COPY('"," or OF expected',msg);
  |  38:COPY('identifier expected',msg);
  |  39:COPY('";" missing',msg);
  |  41:COPY('END missing',msg);
  |  44:COPY('UNTIL missing',msg);
  |  46:COPY('EXIT not within loop statement',msg);
  |  47:COPY('illegally marked identifier',msg);
  |  50:COPY('expression should be constant',msg);
  |  51:COPY('constant not an integer',msg);
  |  52:COPY('identifier does not denote a type',msg);
  |  53:COPY('identifier does not denote a record type',msg);
  |  54:COPY('result type of procedure is not a basic type',msg);
  |  55:COPY('procedure call of a function',msg);
  |  56:COPY('assignment to non-variable',msg);
  |  57:COPY('pointer not bound to record or array type',msg);
  |  58:COPY('recursive type definition',msg);
  |  59:COPY('illegal open array parameter',msg);
  |  60:COPY('wrong type of case label',msg);
  |  61:COPY('inadmissible type of case label',msg);
  |  62:COPY('case label defined more than once',msg);
  |  63:COPY('illegal value of constant',msg);
  |  64:COPY('more actual than formal parameters',msg);
  |  65:COPY('fewer actual than formal parameters',msg);
  |  66:COPY('element types of actual array and formal open array differ',msg);
  |  67:COPY('actual parameter corresponding to open array is not an array',msg);
  |  68:COPY('control variable must be integer',msg);
  |  69:COPY('parameter must be an integer constant',msg);
  |  70:COPY('pointer or VAR record required as formal receiver',msg);
  |  71:COPY('pointer expected as actual receiver',msg);
  |  72:COPY('procedure must be bound to a record of the same scope',msg);
  |  73:COPY('procedure must have level 0',msg);
  |  74:COPY('procedure unknown in base type',msg);
  |  75:COPY('invalid call of base procedure',msg);
  |  76:COPY('this variable (field) is read only',msg);
  |  77:COPY('object is not a record',msg);
  |  78:COPY('dereferenced object is not a variable',msg);
  |  79:COPY('indexed object is not a variable',msg);
  |  80:COPY('index expression is not an integer',msg);
  |  81:COPY('index out of specified bounds',msg);
  |  82:COPY('indexed variable is not an array',msg);
  |  83:COPY('undefined record field',msg);
  |  84:COPY('dereferenced variable is not a pointer',msg);
  |  85:COPY('guard or test type is not an extension of variable type',msg);
  |  86:COPY('guard or testtype is not a pointer',msg);
  |  87:COPY('guarded or tested variable is neither a pointer nor a VAR-parameter record',msg);
  |  88:COPY('open array not allowed as variable, record field or array element',msg);
  |  92:COPY('operand of IN not an integer, or not a set',msg);
  |  93:COPY('set element type is not an integer',msg);
  |  94:COPY('operand of & is not of type BOOLEAN',msg);
  |  95:COPY('operand of OR is not of type BOOLEAN',msg);
  |  96:COPY('operand not applicable to (unary) +',msg);
  |  97:COPY('operand not applicable to (unary) -',msg);
  |  98:COPY('operand of ~ is not of type BOOLEAN',msg);
  |  99:COPY('ASSERT fault',msg);
  | 100:COPY('incompatible operands of dyadic operator',msg);
  | 101:COPY('operand type inapplicable to *',msg);
  | 102:COPY('operand type inapplicable to /',msg);
  | 103:COPY('operand type inapplicable to DIV',msg);
  | 104:COPY('operand type inapplicable to MOD',msg);
  | 105:COPY('operand type inapplicable to +',msg);
  | 106:COPY('operand type inapplicable to -',msg);
  | 107:COPY('operand type inapplicable to = or ##',msg);
  | 108:COPY('operand type inapplicable to relation',msg);
  | 109:COPY('overriding method must be exported',msg);
  | 110:COPY('operand is not a type',msg);
  | 111:COPY('operand inapplicable to (this) function',msg);
  | 112:COPY('operand is not a variable',msg);
  | 113:COPY('incompatible assignment',msg);
  | 114:COPY('string too long to be assigned',msg);
  | 115:COPY("parameter doesn't match",msg);
  | 116:COPY("number of parameters doesn't match",msg);
  | 117:COPY("result type doesn't match",msg);
  | 118:COPY("export mark doesn't match with forward declaration",msg);
  | 119:COPY('redefinition textually precedes procedure bound to base type',msg);
  | 120:COPY('type of expression following IF, WHILE, UNTIL or ASSERT is not BOOLEAN',msg);
  | 121:COPY('called object is not a procedure (or is an interrupt procedure)',msg);
  | 122:COPY('actual VAR-parameter is not a variable',msg);
  | 123:COPY('type of actual parameter is not identical with that of formal VAR-parameter',msg);
  | 124:COPY('type of result expression differs from that of procedure',msg);
  | 125:COPY('type of case expression is neither INTEGER nor CHAR',msg);
  | 126:COPY('this expression cannot be a type or a procedure',msg);
  | 127:COPY('illegal use of object',msg);
  | 128:COPY('unsatisfied forward reference',msg);
  | 129:COPY('unsatisfied forward procedure',msg);
  | 130:COPY('WITH clause does not specify a variable',msg);
  | 131:COPY('LEN not applied to array',msg);
  | 132:COPY('dimension in LEN too large or negative',msg);
  | 135:COPY('SYSTEM not imported',msg);
  | 136:COPY("sysflag doesn't match",msg);
  | 150:COPY('key inconsistency of imported module',msg);
  | 151:COPY('incorrect symbol file',msg);
  | 152:COPY('symbol file of imported module not found',msg);
  | 153:COPY('object or symbol file not opened (disk full?)',msg);
  | 154:COPY('recursive import not allowed',msg);
  | 155:COPY('generation of new symbol file not allowed',msg);
  | 200:COPY('not yet implemented',msg);
  | 201:COPY('lower bound of set range greater than higher bound',msg);
  | 202:COPY('set element greater than MAX(SET) or less than 0',msg);
  | 203:COPY('number too large',msg);
  | 204:COPY('product too large',msg);
  | 205:COPY('division by zero',msg);
  | 206:COPY('sum too large',msg);
  | 207:COPY('difference too large',msg);
  | 208:COPY('overflow in arithmetic shift',msg);
  | 209:COPY('case range too large',msg);
  | 210:COPY('code too long',msg);
  | 211:COPY('jump distance too large',msg);
  | 213:COPY('too many cases in case statement',msg);
  | 215:COPY('not enough registers: simplify expression',msg);
  | 216:COPY('not enough floating-point registers: simplify expression',msg);
  | 218:COPY('illegal value of parameter  (0 <= p <= 32767)',msg);
  | 219:COPY('illegal value of parameter  (0 <= p < 16)',msg);
  | 220:COPY('illegal value of parameter',msg);
  | 221:COPY('too many pointers in a record',msg);
  | 222:COPY('too many global pointers',msg);
  | 223:COPY('too many record types',msg);
  | 224:COPY('too many pointer types',msg);
  | 225:COPY('address of pointer variable too large (move forward in text)',msg);
  | 226:COPY('too many exported procedures',msg);
  | 227:COPY('too many imported modules',msg);
  | 228:COPY('too many exported structures',msg);
  | 229:COPY('too many nested records for import',msg);
  | 230:COPY('too many constants (strings) in module',msg);
  | 231:COPY('too many link table entries (external procedures)',msg);
  | 232:COPY('too many commands in module',msg);
  | 233:COPY('record extension hierarchy too high',msg);
  | 234:COPY('export of recursive type not allowed',msg);
  | 236:COPY('address of exported variable too large (move forward in text)',msg);
  | 240:COPY('identifier too long',msg);
  | 241:COPY('string too long',msg);
  | 242:COPY('address overflow (size of variables, parameters or record too large)',msg);
  | 250:COPY('identifiers in a definition module are not marked',msg);
  | 251:COPY('in a definition module everything must be declared as [_APICALL]',msg);
  | 252:COPY('no variables in a definition module',msg);
  | 253:COPY('no statements in a definition module',msg);
  | 254:COPY('could not create object file',msg);
  | 255:COPY('generated record for object file is too large',msg);
  | 256:COPY('interrupt procedure must be called by an interrupt',msg);
  | 257:COPY('size of local variables too large',msg);
  | 258:COPY('size of global variables too large',msg);
  | 259:COPY('size of parameters too large',msg);
  | 260:COPY('SYSTEM.CC not supported',msg);
  | 261:COPY('register not readable',msg);
  | 262:COPY('read only register',msg);
  | 263:COPY('constant frame too large',msg);
  | 264:COPY('too many imported procedures',msg);
  | 265:COPY("too many fixup's, code too complex",msg);
  | 266:COPY('data record for object file too large',msg);
  | 267:COPY('open array (or pointer to array) containing pointers',msg);
  | 279:COPY('export file not opened (disk full?)',msg);
  | 280:COPY('incorrect license file',msg);
  | 281:COPY('code too long (limited by your license)',msg);
  | 282:COPY('license file not found',msg);
  | 283:COPY('PROCEDURE, BEGIN or END exptected',msg);
  | 299:COPY('internal compiler error',msg);
  | 301:COPY('implicit type cast',msg);
  | 302:COPY('guarded variable can be side-effected',msg);
  | 303:COPY('open array (or pointer to array) containing pointers',msg);
  | 304:COPY('pointer not set to NIL after DISPOSE because variable is write protected',msg);
  | 305:COPY('# has to be spelled "ProgMain" to initiate module initialization',msg);
  | 306:COPY('# has to be spelled "WinMain" to initiate module initialization',msg);
  | 307:COPY('# has to be spelled "DllEntryPoint" to initiate module initialization',msg);
  | 400:COPY('file not found',msg);
  | 401:COPY('path not found',msg);
  | 402:COPY('too many open files',msg);
  | 403:COPY('access denied',msg);
  | 404:COPY('write protected',msg);
  | 405:COPY('sharing violation',msg);
  | 406:COPY('network access denied',msg);
  | 407:COPY('unexpected file error',msg);
  | 408:COPY('could not create file',msg);
  | 409:COPY('symbol file format of a different compiler',msg);
  | 410:COPY('source file name is not identical with module name',msg);
  | 411:COPY('"=" expected',msg);
  | 412:COPY('parameter # is of a basic type, must not be read only VAR param',msg);
  | 413:COPY('illegal sys flag',msg);
  | 414:COPY("the compiler has run out of memory",msg);
  | 415:COPY("too many procedures",msg);
  | 416:COPY("too many lines of code",msg);
  | 417:COPY("parameters may only be declared STATICTYPED in a definition module",msg);
  | 418:COPY("actual STATICTYPED VAR-parameter is not a record type",msg);
  | 419:COPY("type given for STATICTYPED parameter is not a record type",msg);
  | 420:COPY("This should not happen ",msg);
  | 421:COPY("too many types for debug information",msg);
  | 422:COPY("code procedure too long",msg);
  | 423:COPY("out of virtual register space; simplify expression",msg);
  ELSE
    COPY("unexpected error code",msg);
  END;
  IF insText#"" THEN
    i:=0;
    WHILE (msg[i]#"#") & (msg[i]#0X) DO INC(i) END;
    IF (msg[i]="#") & (msg[i+1]="#") THEN
      String.Delete(msg,i+1,1);
    ELSIF msg[i]="#" THEN
      String.Delete(msg,i+1,1);
      String.Insert('"',msg,i+1);
      String.Insert(insText,msg,i+1);
      String.Insert('"',msg,i+1);
    ELSE
      String.Append(msg,' : "');
      String.Append(msg,insText);
      String.Append(msg,'"');
    END;
  END;
END Message;


END Error.
